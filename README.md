# Scheduler Proof of Concept for DATIFY Customer

## Overview

This is a **proof-of-concept task scheduling system** built in Java. It allows the user to generate schedules for tasks, either via a **LLM-based API (Gemini)** or using a **hardcoded fallback dataset**. The application includes a **GUI** for visualizing schedules and recomputing them using different planning strategies.

The main goals of this project are:

- Demonstrate **task extraction** from text using an LLM (Gemini API).
- Showcase **constraint-based scheduling** with task dependencies and ideal time windows.
- Provide a **basic user-friendly GUI** to display schedules and allow recomputation.
- Illustrate a simple architectural design with **strategy patterns** (Backtracking and A*).

> **Motivation:** This project was chosen because it naturally provides a set of tasks described in text, which seemed well-suited for experimentation with LLM-based extraction. At the same time, due to the known risks of hallucination or errors from LLMs, a **hardcoded fallback dataset** ensures reliable testing and reproducibility.

---

## Features

- **Task Seeding**
    - **Gemini API**: Extracts tasks from a text description and generates a structured schedule.
    - **Hardcoded Fallback**: A predefined set of 10 tasks to allow testing without API access.

- **Scheduling Strategies**
    - **Backtracking**: Fully functional with hardcoded tasks or API-generated tasks.
    - **A***: Demonstrates architectural composition but currently only works reliably with the minimal three tasks from the API call. The heuristic for larger task sets is not well-developed.

- **Graphical User Interface (GUI)**
    - Displays tasks on a weekly schedule grid.
    - Allows **strategy selection** (Backtracking / A*) for recomputation.
    - Allows **task source selection** (API / Hardcoded) for recomputation.
---

## Limitations

- This is a **proof-of-concept**, so it is not very well optimized.
- The **10 hardcoded tasks** only work reliably with the **Backtracking** algorithm.
- **A*** currently only works with the three tasks seeded via the API. Its heuristic is not optimized for larger task sets.
- The GUI has been entirely generated by LLM due to time constraints. Its main purpose is to demonstrate scheduling visualization and strategy recomputation.
- LLM-based seeding may **hallucinate or produce inconsistent tasks**, which is why the hardcoded fallback exists for testing and demonstration.

---

## Usage

1. Set the `GOOGLE_API_KEY` environment variable if you want to use the Gemini API for task extraction.
2. Run the `Main.java` class to start the GUI.
3. In the GUI:
    - Select the **task source** (Gemini API or Hardcoded).
    - Select the **planning strategy** (Backtracking or A*).
    - Click **Recompute Schedule** to generate a schedule.
    - Use **Clear Schedule** as needed.

---

## Notes

- **A*** strategy is included primarily to **showcase architectural flexibility**, not for performance.
- The system is designed to be **extensible**, allowing additional task sources or scheduling strategies to be added.  
